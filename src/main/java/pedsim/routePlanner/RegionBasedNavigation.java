package pedsim.routePlanner;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import org.javatuples.Pair;
import pedsim.agents.Agent;
import pedsim.communityCognitiveMap.Gateway;
import pedsim.communityCognitiveMap.Region;
import pedsim.engine.PedSimCity;
import sim.graph.EdgeGraph;
import sim.graph.GraphUtils;
import sim.graph.NodeGraph;
import sim.util.geo.Angles;
import sim.util.geo.Utilities;

/**
 * Series of functions for computing a sequence of region-gateways between the space generated by an
 * origin and a destination. This class generates therefore the so-called navigational coarse plan.
 */
public class RegionBasedNavigation {

  List<Integer> visitedRegions = new ArrayList<>();
  List<Gateway> gatewaySequence = new ArrayList<>();
  List<Gateway> badExits = new ArrayList<>();

  List<NodeGraph> nodesSequence = new ArrayList<>();
  List<NodeGraph> gatewaysToIgnore = new ArrayList<>();

  NodeGraph originNode, destinationNode, currentNode, previousNode;
  int currentRegionID, specificRegionID, targetRegionID;
  boolean finalRegion = false;

  Map<Integer, Gateway> gatewaysMap;
  Map<Gateway, Double> validGateways;
  Map<Gateway, Double> otherGateways;

  private Agent agent;
  private Map<Integer, Region> regionsMap;
  boolean noRegionSequence = false;

  /**
   * Constructs a RegionBasedNavigation object.
   *
   * @param originNode The origin node.
   * @param destinationNode The destination node.
   * @param agent The agent for which region-based navigation is being computed.
   */
  public RegionBasedNavigation(NodeGraph originNode, NodeGraph destinationNode, Agent agent) {
    this.originNode = originNode;
    this.destinationNode = destinationNode;
    this.agent = agent;

    // Create a new filtered map with only entries whose key is in knownRegionIDs
    regionsMap = PedSimCity.regionsMap.entrySet().stream()
        .filter(entry -> agent.getCognitiveMap().getAgentKnownRegions().contains(entry.getKey()))
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

    gatewaySequence = new ArrayList<>();
    gatewaysMap = new HashMap<>();
    validGateways = new HashMap<>();
    otherGateways = new HashMap<>();

  }

  /**
   * Returns a sequence of nodes representing the traversed regions, entry and exit gateways between
   * the origin and the destination.
   *
   * If the agent also uses barriers, barrier sub-goals are also identified when applicable.
   *
   * @return The sequence of nodes representing the planned navigation.
   * @throws Exception
   */
  public List<NodeGraph> sequenceRegions() {

    initializeSequence(); // Extracted initialization logic

    if (!isRegionalSequenceDouable()) {
      noRegionSequence = true;
    }

    while (!finalRegion & !noRegionSequence) {
      nextGateways(); // Extracted logic for handling next gateways
    }

    if (noRegionSequence) {
      agent.getProperties().regionBasedNavigation = false;
      if (agent.getProperties().barrierBasedNavigation) {
        BarrierBasedNavigation barrierBasedNavigation =
            new BarrierBasedNavigation(originNode, destinationNode, agent, false);
        return barrierBasedNavigation.sequenceBarriers();
      }
      nodesSequence.add(destinationNode);
      return nodesSequence;
    }

    // clear the sets
    visitedRegions.clear();
    badExits.clear();
    // sub-goals and barriers - navigation
    List<NodeGraph> sequence = new ArrayList<>();
    // if also barrier navigation, insert barrier-sub goals into the sequence
    if (agent.getProperties().barrierBasedNavigation) {
      sequence = regionalBarriers();
    } else {
      // TOdo
      sequence = nodesSequence;
    }

    // remove duplicates and maintains order
    Set<NodeGraph> ns = new LinkedHashSet<>(sequence);
    sequence = new ArrayList<>(ns);
    return sequence;
  }

  private boolean isRegionalSequenceDouable() {
    return (regionsMap.containsKey(currentRegionID) && regionsMap.containsKey(targetRegionID))
        & (currentRegionID != targetRegionID);
  }

  /**
   * Initialises the sequence of nodes and regions for navigation.
   */
  private void initializeSequence() {

    this.gatewaysMap = PedSimCity.gatewaysMap;
    currentNode = originNode;
    currentRegionID = originNode.getRegionID();
    targetRegionID = destinationNode.getRegionID();
    nodesSequence.add(originNode);
    visitedRegions.add(currentRegionID);
    previousNode = null;

  }

  /**
   * Finds the next gateways. This method calculates the next gateways based on the current node and
   * region, updates the sequence of gateways, and maintains necessary tracking information for the
   * navigation process.
   */
  private void nextGateways() {
    Gateway gateway = findNextGateway(currentNode, currentRegionID, -1);
    if (gateway == null) {
      handleInvalidGateway();
      return;
    }
    updateGatewaySequence(gateway);
  }

  /**
   * Handles an invalid gateway encountered during navigation. This method identifies the invalid
   * gateway pair, adds it to the list of bad exits to avoid it in future calculations, reverts the
   * navigation state to the previous node, updates tracking information, and resets the gateway
   * sequence.
   */
  private void handleInvalidGateway() {
    // if not coming from a Bad Gateway
    if (previousNode != null) {
      Gateway badGateway = gatewaySequence.get(gatewaySequence.size() - 1);
      badExits.add(badGateway);
      currentNode = previousNode;
      currentRegionID = previousNode.getRegionID();
      gatewaySequence = new ArrayList<>(gatewaySequence.subList(0, gatewaySequence.size() - 1));
      visitedRegions.remove(visitedRegions.size() - 1);
      previousNode = null;
    } else { // Coming Already from a bad Gateway
      noRegionSequence = true;
    }

  }

  /**
   * Identifies the next gateway (exit and entry nodes) towards the best region for the current
   * location and region.
   *
   * @param currentNode The current node.
   * @param currentRegion The current region.
   * @param specificRegionID A desired region (optional).
   * @return The pair of gateways representing the next step in navigation.
   */
  private Gateway findNextGateway(NodeGraph currentNode, int currentRegion, int specificRegionID) {

    List<Gateway> knownGateways = getKnownGateways(currentRegion);
    if (knownGateways.isEmpty()) {
      return null;
    }

    validGateways = new ConcurrentHashMap<>();
    otherGateways = new ConcurrentHashMap<>();

    double destinationAngle = Angles.angle(currentNode, destinationNode);
    double distanceTarget = GraphUtils.nodesDistance(currentNode, destinationNode);

    knownGateways.parallelStream().forEach(gateway -> {
      if (isGatewayValid(gateway, specificRegionID)) {
        evaluateGateway(gateway, destinationAngle, distanceTarget, currentNode);
      }
    });

    if (validGateways.isEmpty() && specificRegionID != -1) {
      return null;
    }
    if (validGateways.isEmpty()) {
      validGateways = otherGateways;
    }
    if (validGateways.isEmpty()) {
      return null;
    }

    // sort the valid gates, rewarding the ones with the lowest deviation towards
    // the destination
    Map<Gateway, Double> validSorted = Utilities.sortByValue(validGateways, false);
    // return the first gateway pair
    for (Entry<Gateway, Double> gatewaysPair : validSorted.entrySet()) {
      return gatewaysPair.getKey();
    }
    return null;
  }

  private List<Gateway> getKnownGateways(int currentRegion) {

    // Check if regionsMap.get(currentRegion) is null
    if (regionsMap.get(currentRegion) == null) {
      return Collections.emptyList(); // Return an empty
    }
    // list if
    // currentRegion is
    // not found
    List<Gateway> possibleGateways = new ArrayList<>(regionsMap.get(currentRegion).gateways);
    return possibleGateways.stream()
        .filter(gateway -> agent.getCognitiveMap().isInKnownNetwork(gateway.entry))
        .filter(gateway -> agent.getCognitiveMap().isInKnownNetwork(gateway.exit))
        .filter(gateway -> regionsMap.containsKey(gateway.regionTo)).collect(Collectors.toList());
  }

  /**
   * Checks the validity of a gateway.
   *
   * @param gateway The gateway to be checked for validity.
   * @param specificRegionID The specific region ID to which the gateway should belong, or -1 if any
   *        region is acceptable.
   * @return True if the gateway is valid based on the specified conditions, otherwise false.
   */
  private boolean isGatewayValid(Gateway gateway, int specificRegionID) {

    if (badExits.contains(gateway)
        || (specificRegionID != -1 && specificRegionID != gateway.regionTo)) {
      return false;
    }
    if (visitedRegions.contains(gateway.regionTo)) {
      return false;
    } else {
      return true;
    }
  }

  /**
   * Evaluates the given gateway based on the criteria.
   *
   * @param gateway The gateway being evaluated.
   * @param destinationAngle The angle towards the destination.
   * @param distanceTarget The distance to the target.
   * @param currentNode The current node in the navigation process.
   */
  private void evaluateGateway(Gateway gateway, double destinationAngle, double distanceTarget,
      NodeGraph currentNode) {

    double locationExitAngle = Angles.angle(currentNode, gateway.exit);
    double exitEntryAngle = gateway.entryAngle;
    double exitDestintionAngle = Angles.angle(gateway.exit, destinationNode);
    double differenceExitEntry = Angles.differenceAngles(locationExitAngle, exitDestintionAngle);
    double distanceFromGate = GraphUtils.nodesDistance(currentNode, gateway.exit);

    double cost = 0.0;
    boolean entryInDirection = Angles.isInDirection(destinationAngle, exitEntryAngle, 140.0);
    boolean exitInDirection = Angles.isInDirection(destinationAngle, locationExitAngle, 140.0);
    boolean notInDirection =
        (distanceFromGate > distanceTarget || !exitInDirection || !entryInDirection);
    // criteria are not met
    if (isCurrentExit(gateway) && !entryInDirection) {
      cost = Angles.differenceAngles(exitEntryAngle, destinationAngle);
      otherGateways.put(gateway, cost);
    } else if (!isCurrentExit(gateway) && notInDirection) {
      addInvalidGateway(gateway, locationExitAngle, destinationAngle, differenceExitEntry);
    } else {
      addValidGateway(gateway, locationExitAngle, destinationAngle, differenceExitEntry);
    }

  }

  /**
   * Checks if the given gateway's exit matches the current node in the navigation.
   *
   * @param gateway The gateway to be checked.
   * @return True if the gateway's exit matches the current node, false otherwise.
   */
  private boolean isCurrentExit(Gateway gateway) {
    return gateway.exit.equals(currentNode);
  }

  /**
   * Adds the given gateway to the 'otherGateways' collection based on certain criteria.
   *
   * @param gateway The gateway to be added.
   * @param locationExitAngle The angle of the exit location.
   * @param destinationAngle The angle towards the destination.
   * @param differenceExitEntry The difference between exit and entry angles.
   */
  private void addInvalidGateway(Gateway gateway, double locationExitAngle, double destinationAngle,
      double differenceExitEntry) {
    double cost = Angles.differenceAngles(locationExitAngle, destinationAngle);
    if (cost <= 90) {
      cost += differenceExitEntry;
      otherGateways.put(gateway, cost);
    }
  }

  /**
   * Adds a valid gateway based on specific angles and differences, storing it in 'validGateways'.
   *
   * @param gateway The gateway being evaluated.
   * @param locationExitAngle The angle of the exit location.
   * @param destinationAngle The angle towards the destination.
   * @param differenceExitEntry The difference between exit and entry angles.
   */
  private void addValidGateway(Gateway gateway, double locationExitAngle, double destinationAngle,
      double differenceExitEntry) {
    double cost;
    if (isCurrentExit(gateway)) {
      cost = Angles.differenceAngles(gateway.entryAngle, destinationAngle);
    } else {
      cost = Angles.differenceAngles(locationExitAngle, destinationAngle) + differenceExitEntry;
    }
    validGateways.put(gateway, cost);
  }

  private void updateGatewaySequence(Gateway gateway) {

    previousNode = currentNode;
    gatewaySequence.add(gateway);
    currentNode = gateway.entry;
    currentRegionID = currentNode.getRegionID();
    visitedRegions.add(currentRegionID);

    if (currentRegionID == targetRegionID) {
      finaliseSequence();
    }
  }

  private void finaliseSequence() {
    finalRegion = true;

    for (Gateway gateway : gatewaySequence) {
      nodesSequence.add(gateway.exit);
      nodesSequence.add(gateway.entry);
    }
    nodesSequence.add(destinationNode);
  }

  /**
   * Identifies barriers within the regions traversed and inserts barrier sub-goals into the
   * sequence of gateways when applicable.
   *
   * @return The sequence with added barrier sub-goals.
   * @throws Exception
   */
  private List<NodeGraph> regionalBarriers() {

    List<NodeGraph> gatewaySequenceWithSubGoals = new ArrayList<>();
    BarrierBasedNavigation barrierBasedNavigation =
        new BarrierBasedNavigation(originNode, destinationNode, agent, true);

    for (NodeGraph gateway : nodesSequence) {

      if (gatewaysToIgnore.contains(gateway)) {
        continue;
      }
      gatewaySequenceWithSubGoals.add(gateway);
      if (gateway.equals(destinationNode)) {
        break;
      }
      int indexOf = nodesSequence.indexOf(gateway);
      // continue for exit gateways and destination
      if (indexOf > 0 && indexOf % 2 != 0) {
        continue;
      }

      // check if there are good barriers in line of movement towards the destination,
      // inside the region
      Region region = regionsMap.get(gateway.getRegionID());
      Map<Integer, Double> validBarriers =
          barrierBasedNavigation.findValidBarriers(gateway, region);
      if (validBarriers.isEmpty()) {
        continue;
      }

      // given the best valid barriers, identify the best one and the relative
      // reference-edge
      Pair<EdgeGraph, Integer> barrierGoal =
          barrierBasedNavigation.identifyBarrierSubGoal(validBarriers, region);
      if (barrierGoal == null) {
        continue;
      }

      // gets the subGoal from one of the edges' nodes.
      NodeGraph subGoal = null;
      EdgeGraph edgeGoal = barrierGoal.getValue0();
      int barrierID = barrierGoal.getValue1();

      // pick the closest barrier sub-goal
      if (GraphUtils.nodesDistance(gateway, edgeGoal.getFromNode()) < GraphUtils
          .nodesDistance(gateway, edgeGoal.getToNode())) {
        subGoal = edgeGoal.getFromNode();
      } else {
        subGoal = edgeGoal.getToNode();
      }

      barrierBasedNavigation.visitedBarriers.add(barrierID);
      // if this subgoal it's already in the sequence, i.e if it's an exit, continue
      if (nodesSequence.contains(subGoal)) {
        continue;
      }
      gatewaySequenceWithSubGoals.add(subGoal);

      // if this is the entry gateway to the last region
      if (indexOf == nodesSequence.size() - 2) {
        continue;
      }
      targetRegionID = nodesSequence.get(indexOf + 2).getRegionID();

      // if subGoal is a newGateway itself and it leads to the next region
      // else, if the subGoal is not a gateway, check whether there's a better gateway
      // towards the next region (desiredRegion)
      if (subGoal.gateway && subGoal.adjacentRegions.contains(targetRegionID)) {
        amendGatewaySequence(subGoal, indexOf);
      } else {
        Gateway newGateway = findNextGateway(subGoal, subGoal.getRegionID(), targetRegionID);
        if (newGateway == null) {
          continue;
        }
        nodesSequence.set(indexOf + 1, newGateway.exit);
        nodesSequence.set(indexOf + 2, newGateway.entry);
      }
    }
    return gatewaySequenceWithSubGoals;
  }

  /**
   * Updates the gatewaySequence, if the barrier-subGoal is a newGateway itself and it leads to the
   * next region; no need to go through another gateway
   *
   * @param subGoal The sub-goal node to process.
   * @param indexOf The index of previously defined identified exit in the sequence.
   */
  private void amendGatewaySequence(NodeGraph subGoal, int indexOf) {

    // a) ignore the next exit
    gatewaysToIgnore.add(nodesSequence.get(indexOf + 1));

    // b) get a new entry
    double deviation = Double.MAX_VALUE;
    NodeGraph bestEntry = null;
    for (NodeGraph entry : subGoal.adjacentRegionEntries) {
      if (entry.getRegionID() != targetRegionID) {
        continue;
      }
      double entryAngle = Angles.angle(subGoal, entry);
      if (entryAngle < deviation) {
        deviation = entryAngle;
        bestEntry = entry;
      }
    }
    // c) replace the old entry
    nodesSequence.set(indexOf + 2, bestEntry);
  }
}
